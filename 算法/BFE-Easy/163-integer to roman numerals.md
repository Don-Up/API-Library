## [163. integer to roman numerals | BFE.dev - prepare for Front-End job interviews.](https://bigfrontend.dev/problem/integer-to-roman)

这道题要求实现一个函数 `integerToRoman`，将输入的整数转换为对应的罗马数字表示。罗马数字由固定的七个符号（I, V, X, L, C, D, M）和特定规则构成，其中包括减法表示法（如 4 表示为 IV 而不是 IIII）。输入是一个整数，范围在有效罗马数字表示范围内（1 到 3999），输出是一个字符串，表示该整数对应的罗马数字。

### **讲解内容**

#### 1. **函数 `integerToRoman` 的目的**

- 该函数的目标是将输入的整数（`1` ~ `3999`）转换为对应的罗马数字表示。
- 罗马数字由以下七个符号组成：
  - `I`（1）、`V`（5）、`X`（10）、`L`（50）、`C`（100）、`D`（500）、`M`（1000）。
- 特定规则包括：
  - 数字从大到小依次组合。
  - 减法规则：当小的数字出现在大的数字左边时，表示减法。例如 `4` 表示为 `IV`，`9` 表示为 `IX`。

#### 2. **使用递归的思想**

- 函数通过递归的方式，逐步从输入整数中减去最大可能的罗马数字值，同时将对应的符号添加到结果字符串中。
- 递归的终止条件是输入整数 `num` 为 `0`，此时返回构造好的罗马数字字符串。

---

#### 3. **核心逻辑**

1. **查找最大符号**：
   - 使用 `lookup.find()` 查找输入整数 `num` 当前可以用的最大罗马数字符号及其对应的值（`value`）。
   - 例如，当 `num = 58` 时，会找到符号 `L`（50）。

2. **递归调用**：
   - 从输入整数中减去当前符号对应的值 `value`，并在结果字符串中追加该符号。
   - 继续对剩余的值递归调用函数，直到 `num` 为 `0`。

3. **返回结果**：
   - 递归完成后，返回构造好的罗马数字字符串。

---

### **带有注释的完整代码**

```javascript
const lookup = [
  { symbol: 'M', value: 1000 },
  { symbol: 'CM', value: 900 },
  { symbol: 'D', value: 500 },
  { symbol: 'CD', value: 400 },
  { symbol: 'C', value: 100 },
  { symbol: 'XC', value: 90 },
  { symbol: 'L', value: 50 },
  { symbol: 'XL', value: 40 },
  { symbol: 'X', value: 10 },
  { symbol: 'IX', value: 9 },
  { symbol: 'V', value: 5 },
  { symbol: 'IV', value: 4 },
  { symbol: 'I', value: 1 },
];

/**
 * @param {number} num - 输入的整数
 * @param {string} res - 存储结果的罗马数字字符串，默认为空字符串
 * @returns {string} - 转换后的罗马数字字符串
 */
const integerToRoman = (num, res = '') => {
  // 如果 num 为 0，递归结束，返回结果字符串
  if (num === 0) {
    return res;
  }

  // 查找当前 num 可用的最大罗马数字符号和对应值
  const { symbol, value } = lookup.find(({ value }) => num >= value);

  // 减去当前符号对应的值，并将符号追加到结果字符串
  return integerToRoman(num - value, `${res}${symbol}`);
};
```

---

### **逐步执行示例**

#### 示例 1:  

**输入**: `1994`  
**过程**:  

1. 初始值：`num = 1994`，`res = ''`。  
2. 第一次查找：`1994 >= 1000`，找到符号 `M`，减去 `1000`，结果为 `num = 994`，`res = 'M'`。  
3. 第二次查找：`994 >= 900`，找到符号 `CM`，减去 `900`，结果为 `num = 94`，`res = 'MCM'`。  
4. 第三次查找：`94 >= 90`，找到符号 `XC`，减去 `90`，结果为 `num = 4`，`res = 'MCMXC'`。  
5. 第四次查找：`4 >= 4`，找到符号 `IV`，减去 `4`，结果为 `num = 0`，`res = 'MCMXCIV'`。  
6. 结束递归，返回结果：`'MCMXCIV'`。  

**输出**: `"MCMXCIV"`

---

#### 示例 2:  

**输入**: `58`  
**过程**:  

1. 初始值：`num = 58`，`res = ''`。  
2. 第一次查找：`58 >= 50`，找到符号 `L`，减去 `50`，结果为 `num = 8`，`res = 'L'`。  
3. 第二次查找：`8 >= 5`，找到符号 `V`，减去 `5`，结果为 `num = 3`，`res = 'LV'`。  
4. 第三次查找：`3 >= 1`，找到符号 `I`，减去 `1`，结果为 `num = 2`，`res = 'LVI'`。  
5. 第四次查找：`2 >= 1`，找到符号 `I`，减去 `1`，结果为 `num = 1`，`res = 'LVII'`。  
6. 第五次查找：`1 >= 1`，找到符号 `I`，减去 `1`，结果为 `num = 0`，`res = 'LVIII'`。  
7. 结束递归，返回结果：`'LVIII'`。  

**输出**: `"LVIII"`

---

#### 示例 3:  

**输入**: `3999`  
**过程**:  

1. 初始值：`num = 3999`，`res = ''`。  
2. 第一次查找：`3999 >= 1000`，找到符号 `M`，减去 `1000`，结果为 `num = 2999`，`res = 'M'`。  
3. 重复第 2 步两次，最终 `num = 999`，`res = 'MMM'`。  
4. 查找 `999 >= 900`，找到符号 `CM`，减去 `900`，结果为 `num = 99`，`res = 'MMMCM'`。  
5. 查找 `99 >= 90`，找到符号 `XC`，减去 `90`，结果为 `num = 9`，`res = 'MMMCMXC'`。  
6. 查找 `9 >= 9`，找到符号 `IX`，减去 `9`，结果为 `num = 0`，`res = 'MMMCMXCIX'`。  
7. 结束递归，返回结果：`'MMMCMXCIX'`。  

**输出**: `"MMMCMXCIX"`

---

### **时间和空间复杂度分析**

1. **时间复杂度**:  
   - 每次递归都会减去当前最大可能的罗马数字值，最多需要执行 `O(n)` 次递归，其中 `n` 是输入数字的大小（最多为 3999）。因此时间复杂度为 **O(n)**。

2. **空间复杂度**:  
   - 每次递归调用会在调用栈中存储函数状态，因此空间复杂度为 **O(n)**（递归深度最多为输入数字的大小）。

---

### **总结**

- 使用递归的方式非常直观地将整数转换为罗马数字，代码简洁清晰。
- 查找最大可用符号的逻辑保证了罗马数字的正确性。
- 这种方法适用于处理罗马数字特殊规则（如减法规则）。

解题方案基于贪心算法，从高位到低位依次构造罗马数字。首先定义一个查找表 `lookup`，按从大到小的顺序排列所有可能的符号及其对应的数值（包括减法表示法如 CM 和 IV）。然后递归或迭代地从查找表中找到当前数字可以表示的最大符号，减去该符号对应的值并将符号添加到结果字符串中，直到输入的数字减为 0 为止。上述方法确保每次尽量用大的符号表示，从而符合罗马数字的构造规则。时间复杂度为 O(n)，其中 n 是数字大小的位数，因为查找表的长度固定；空间复杂度为 O(1)，只需要存储结果字符串和临时变量。此方法简单高效，能够正确处理所有合法输入。



